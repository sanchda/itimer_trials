# This strategy didn't quite work out for me, but it's here for posterity


## Use the official i686 Alpine Linux image as the base image
## (note that i386 is x86/i686)
#FROM i386/alpine:latest
#
## Configure and build Rust using the installed minimal toolchain
## QEMU-emulated systems may incorrectly reveal the emulated architecture via
## uname, so this is a quick hack to fix things up
#COPY uname /usr/bin/uname
#RUN chmod +x /usr/bin/uname

# Install required packages and dependencies
# Note: presumes the current BUILDPLATFORM has rust on alpine
FROM --platform=$BUILDPLATFORM rust:alpine as builder
RUN apk add --no-cache \
    bash \
    build-base \
    clang \
    clang-dev \
    cmake \
    curl \
    file \
    g++ \
    gcc \
    git \
    libffi-dev \
    linux-headers \
    llvm \
    llvm-dev \
    musl-dev \
    ninja \
    openssl \
    openssl-dev \
    perl \
    python3 \
    rust \
    tzdata \
    wget

# Download the Rust nightly source code
ENV RUST_VERSION=nightly
RUN wget https://static.rust-lang.org/dist/rustc-nightly-src.tar.xz && \
    tar -xf rustc-nightly-src.tar.xz && \
    mv rustc-nightly-src rust

# To perform this procedure, rust assumes we have musl-gcc, which isn't part of
# alpine.  But we can make a symlink to gcc and pretend.
RUN ln -s /usr/bin/gcc /usr/bin/musl-gcc
RUN ln -s /usr/bin/g++ /usr/bin/musl-g++

# Try to build the target Rust toolchain
#WORKDIR /rust
#COPY config.toml .
#RUN python3 ./x.py build --stage 0 && \
#    python3 ./x.py build --stage 1 --host x86_64-unknown-linux-musl --target i686-unknown-linux-musl && \
#    python3 ./x.py dist --host x86_64-unknown-linux-musl --target i686-unknown-linux-musl


# Set the working directory for the application
#WORKDIR /app

# Copy the current directory contents into the container
#COPY . .

# Build the project (this step is optional and depends on your project's structure)
# RUN cargo build --release

# Command to run your application (replace with your actual application command)
#CMD ["cargo", "run"]
